<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yi Jiao Â· è‡ªç”±ä¹¦å†™ (æ”¯æŒä¸­æ–‡)</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #393939; font-family: 'Microsoft YaHei', sans-serif; color: white; }
        body { display: flex; flex-direction: row; }
        #sidebar { width: 320px; min-width: 320px; height: 100vh; background: #2c2c2c; padding: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 20; box-shadow: 2px 0 10px rgba(0,0,0,0.5); overflow-y: auto; box-sizing: border-box; }
        #canvas-container { flex: 1; height: 100%; position: relative; background-color: #393939; min-width: 0; }
        
        .header-box { border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center;}
        .header-box h1 { font-size: 18px; color: #f39c12; margin: 0; letter-spacing: 1px; }
        .back-btn { color: #aaa; text-decoration: none; font-size: 12px; padding: 4px 8px; background: #3d3d3d; border-radius: 3px; border: 1px solid #555;}
        
        label { display: block; margin-bottom: 5px; font-size: 12px; color: #bbb; font-weight: bold; margin-top: 10px; }
        .option-group { display: flex; gap: 8px; flex-wrap: wrap; }
        .material-btn { width: 42px; height: 42px; border-radius: 4px; border: 2px solid #444; background-size: cover; cursor: pointer; }
        .material-btn.active { border-color: #f39c12; box-shadow: 0 0 5px #f39c12; }
        .material-btn.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }
        
        #frontColorPicker, #ledColorPicker { width: 100%; height: 35px; border: 1px solid #444; background: none; cursor: pointer; padding: 0; border-radius: 3px; }
        
        #textInput { 
            width: 100%; padding: 12px; background: #eee; border: none; 
            color: #000; font-size: 20px; border-radius: 4px; outline: none;
            font-weight: bold; text-align: center; letter-spacing: 2px;
            text-transform: uppercase; box-sizing: border-box;
        }
        #textInput:focus { box-shadow: 0 0 0 3px #f39c12; }

        #fontSelector, #craftSelect {
            width: 100%; padding: 10px; background: #3d3d3d; border: 1px solid #555; 
            color: white; font-size: 14px; border-radius: 3px; outline: none;
            cursor: pointer; margin-bottom: 5px;
        }
        #fontSelector option, #craftSelect option { background: #2c2c2c; }

        input[type=range] { width: 100%; padding: 8px; background: #3d3d3d; border: 1px solid #555; color: white; border-radius: 3px; outline: none; box-sizing: border-box; }
        input[type=range]:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .action-btn { width: 100%; padding: 12px; background: #4a4a4a; border: 1px solid #666; color: white; font-weight: bold; border-radius: 3px; cursor: pointer; margin-top: auto; }
        .action-btn:hover { background: #555; border-color: #f39c12; }
        .action-btn:disabled { opacity: 0.5; cursor: not-allowed; background: #333; border-color: #444; }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 10px; pointer-events: none; z-index: 100; background: rgba(0,0,0,0.6); padding: 20px; border-radius: 8px;}
        .spinner { width: 30px; height: 30px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #f39c12; border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        @media (max-width: 768px) { body { flex-direction: column; } #sidebar { width: 100%; height: 45vh; } #canvas-container { height: 55vh; } }

        .note { font-size: 11px; color: #888; margin-top: 5px; text-align: center; border-top: 1px solid #3a3a3a; padding-top: 8px; }
        
        .thickness-control {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #f39c12;
            margin-top: 5px;
        }
        .thickness-control label {
            margin-top: 0;
        }

        /* ç¦ç”¨çŠ¶æ€çš„é®ç½©å±‚ */
        .disabled-overlay { position: relative; opacity: 0.4; pointer-events: none; }
        .disabled-picker { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }
        
        /* éšè—å…ƒç´ çš„ç±» */
        .hidden { display: none !important; }
    </style>
    
  <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.12.2/gsap.min.js"></script>

<script type="importmap">
    { 
        "imports": { 
            "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/" 
        } 
    }
</script>
</head>
<body>

    <div id="sidebar">
        <div class="header-box">
            <h1 id="pageTitle">è‡ªç”±ä¹¦å†™ Â· ä¸­æ–‡æ”¯æŒ</h1>
            <a href="index.html" class="back-btn">â† è¿”å›</a>
        </div>

        <!-- å·¥è‰ºé€‰æ‹©ä¸‹æ‹‰èœå• -->
        <div>
            <label>âš™ï¸ å·¥è‰ºé€‰æ‹©</label>
            <select id="craftSelect">
                <option value="backGlow" selected>é‡‘å±åå£èƒŒé¢å‘å…‰å­—</option>
                <option value="frontGlow">é‡‘å±åå£æ­£é¢å‘å…‰å­—</option>
                <option value="acrylicCut">äºšå…‹åŠ›åˆ‡å‰²å­— (Acrylic Cut)</option>
                <option value="metalCut">é‡‘å±å­— (Metal Cut)</option>
                <option value="boxLight">æ–¹ä½“ç¯ç®± (Box Light)</option>
            </select>
        </div>

        <div>
            <label style="color:#f39c12">âœ è¾“å…¥æ–‡å­— (ä¸­ / è‹±)</label>
            <input type="text" id="textInput" value="YiJiao" maxlength="10" placeholder="è¾“å…¥ä¸­æ–‡æˆ–è‹±æ–‡">
        </div>

        <div>
            <label>ğŸ”¤ å­—ä½“é€‰æ‹©</label>
            <select id="fontSelector">
                <option value="helvetiker" selected>è‹±æ–‡å­—ä½“ Helvetiker (é»˜è®¤)</option>
                <option value="Forte">forteå¸¸è§„å­—</option>
                <option value="STXingkai_Regular">ä¸­æ–‡å­—ä½“ è¡Œä¹¦ (éœ€æ”¾ç½®æ–‡ä»¶)</option>
            </select>
        </div>
        
        <div id="materialSection">
            <label>âš™ï¸ é‡‘å±æè´¨ (Metal Material)</label>
            <div class="option-group" id="materialOptions">
                <div class="material-btn active" style="background-image: url('textures/Metal011_2K-JPG_Color.jpg');" data-type="metal011" title="é‡‘å±æ‹‰ä¸"></div>
                <div class="material-btn" style="background-image: url('textures/Metal049A_2K-JPG_Color.jpg');" data-type="metal049a" title="é‡‘å±é•œé¢"></div>
                <div class="material-btn" style="background-image: url('textures/Metal011_2K-JPG_Color.jpg'); background-color: #c07c51; background-blend-mode: multiply;" data-type="copper_brushed" title="é“œè‰²æ‹‰ä¸"></div>
                <div class="material-btn" style="background-image: url('textures/Metal049A_2K-JPG_Color.jpg'); background-color: #c07c51; background-blend-mode: multiply;" data-type="copper_mirror" title="é“œè‰²é•œé¢"></div>
            </div>
        </div>

        <div id="tintSection">
            <label>ğŸ¨ é‡‘å±è°ƒè‰² (Tint Color)</label>
            <input type="color" id="frontColorPicker" value="#ffffff">
        </div>

        <div id="ledSection">
            <label id="ledColorLabel">ğŸ’¡ ç¯å…‰é¢œè‰² (LED Color)</label>
            <input type="color" id="ledColorPicker" value="#ffffff">
            
            <div id="brightnessControl">
                <label style="margin-top:10px;">äº®åº¦è°ƒèŠ‚ (<span id="brightnessValue">15%</span>)</label>
                <input type="range" id="brightnessSlider" min="0" max="100" step="1" value="15">
            </div>
        </div>

        <!-- 1. æ­£é¢åšåº¦ / ç¯ç®±é•¿ -->
        <div class="thickness-control">
            <label id="frontLabel">ğŸ“ æ­£é¢åšåº¦ (<span id="frontThicknessValue">5.0</span>)</label>
            <input type="range" id="frontThicknessSlider" min="0.5" max="25" step="0.1" value="5">
            <div id="frontDesc" style="font-size:11px; color:#aaa;">å‘å‰å‡¸èµ·</div>
        </div>

        <!-- 2. èƒŒé¢åšåº¦ / ç¯ç®±é«˜ -->
        <div class="thickness-control">
            <label id="backLabel">ğŸ“ èƒŒé¢åšåº¦ (<span id="backThicknessValue">5.0</span>)</label>
            <input type="range" id="backThicknessSlider" min="0.5" max="25" step="0.1" value="5">
            <div id="backDesc" style="font-size:11px; color:#aaa;">å‘åå‡¸èµ·</div>
        </div>
        
        <!-- 3. ç¯ç®±å®½ (æ–°å¢) -->
        <div class="thickness-control hidden" id="depthControl">
            <label>ğŸ“ æ§åˆ¶ç¯ç®±å®½ (<span id="depthValue">10.0</span>)</label>
            <input type="range" id="depthSlider" min="5" max="40" step="0.5" value="10">
            <div style="font-size:11px; color:#aaa;">Zè½´æ–¹å‘å®½åº¦</div>
        </div>
        
        <button class="action-btn" id="decomposeBtn">ä¸€é”®è§£ä½“ (Explode)</button>
    </div>

    <div id="canvas-container">
        <div id="loading"><div class="spinner"></div><span>åŠ è½½å­—ä½“åº“...</span></div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js'; 
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    // ==========================================
    // å…¨å±€çŠ¶æ€ç®¡ç†
    // ==========================================
    let currentTexName = 'Metal011';
    let currentIsBrushed = true;
    let currentTintColor = 0xffffff;

    // å·¥è‰ºæ¨¡å¼ï¼š'backGlow', 'frontGlow', 'acrylicCut', 'metalCut', 'boxLight'
    let glowMode = 'backGlow'; 

    // å°ºå¯¸æ§åˆ¶
    // æ³¨æ„ï¼šåœ¨æ™®é€šæ¨¡å¼ä¸‹ front/back ä¸ºåšåº¦ï¼›åœ¨ boxLight æ¨¡å¼ä¸‹ï¼Œå®ƒä»¬è¢«æ˜ å°„ä¸º é•¿åº¦æ‰©å±• å’Œ é«˜åº¦æ‰©å±•
    let frontThickness = 5.0; // æ˜ å°„ä¸º Box Length Padding
    let backThickness = 5.0;  // æ˜ å°„ä¸º Box Height Padding
    let boxDepth = 10.0;      // ä»…ç”¨äº boxLight

    // å­—ä½“ç›¸å…³
    let currentFont = null;
    let fontLoader = new FontLoader();
    
    // æ ¸å¿ƒç»„
    let frontMeshes = [];    // æ™®é€šæ¨¡å¼æ­£é¢ / ç›’å­æ¨¡å¼çš„å†…éƒ¨é‡‘å±å­—
    let backMeshes = [];     // æ™®é€šæ¨¡å¼èƒŒé¢ / ç›’å­æ¨¡å¼çš„å¤–éƒ¨å‘å…‰ç›’
    let singleMesh = null;   // å•ä½“æ¨¡å¼
    let isDecomposed = false;
    let textGroup = new THREE.Group();
    
    // åœºæ™¯åŸºç¡€
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const blenderBgColor = new THREE.Color('#393939');
    scene.background = blenderBgColor;
    scene.fog = new THREE.Fog(blenderBgColor, 100, 1000); 

    const gridSize = 4000;
    const gridDivisions = 400;
    const gridColor = new THREE.Color('#464646'); 
    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
    scene.add(gridHelper);

    const xAxis = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-gridSize/2,0,0), new THREE.Vector3(gridSize/2,0,0)]),
        new THREE.LineBasicMaterial({ color: '#c44550', linewidth: 1 })
    );
    scene.add(xAxis);

    const zAxis = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-gridSize/2), new THREE.Vector3(0,0,gridSize/2)]),
        new THREE.LineBasicMaterial({ color: '#7dab4f', linewidth: 1 })
    );
    scene.add(zAxis);

    scene.add(textGroup);

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8; 
    container.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ==========================================
    // åå¤„ç† (è¾‰å…‰)
    // ==========================================
    const BLOOM_SCENE = 1; 
    const bloomLayer = new THREE.Layers();
    bloomLayer.set(BLOOM_SCENE);

    const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
    const darkLineMaterial = new THREE.LineBasicMaterial({ color: 'black' }); 
    const materials = {}; 

    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 1, 0); 
    const bloomComposer = new EffectComposer(renderer);
    bloomComposer.renderToScreen = false;
    bloomComposer.addPass(renderScene);
    bloomComposer.addPass(bloomPass);

    const mixPass = new ShaderPass(
        new THREE.ShaderMaterial({
            uniforms: {
                baseTexture: { value: null },
                tBloom: { value: bloomComposer.renderTarget2.texture }
            },
            vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); } `,
            fragmentShader: ` uniform sampler2D baseTexture; uniform sampler2D tBloom; varying vec2 vUv; void main() { gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( tBloom, vUv ) ); } `
        }), "baseTexture"
    );
    mixPass.needsSwap = true;

    const finalComposer = new EffectComposer(renderer);
    finalComposer.addPass(renderScene);
    finalComposer.addPass(mixPass);
    finalComposer.addPass(new OutputPass()); 

    new RGBELoader().setPath('textures/').load('monochrome_studio_02_2k (1).hdr', (t) => {
        t.mapping = THREE.EquirectangularReflectionMapping; 
        scene.environment = t; 
        scene.environmentIntensity = 0; 
    });

    scene.add(new THREE.AmbientLight(0xffffff, 0));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(50, 100, 50);
    scene.add(light);

    // ==========================================
    // æè´¨åˆ›å»ºç³»ç»Ÿ
    // ==========================================
    const textureLoader = new THREE.TextureLoader();
    
    function createBackMaterial(texName, isBrushed, tintColor = 0xffffff) {
        const map = textureLoader.load(`textures/${texName}_2K-JPG_Color.jpg`);
        const normalMap = textureLoader.load(`textures/${texName}_2K-JPG_NormalGl.jpg`);
        const roughnessMap = textureLoader.load(`textures/${texName}_2K-JPG_Roughness.jpg`);

        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(tintColor),
            map: map, 
            normalMap: isBrushed ? normalMap : null,
            roughnessMap: roughnessMap, 
            metalness: 1.0, 
            roughness: isBrushed ? 0.5 : 0.5, 
            envMapIntensity: isBrushed ? 0.5 : 0.5, 
            side: THREE.DoubleSide
        });

        if (isBrushed) {
            mat.onBeforeCompile = (shader) => {
                shader.uniforms.uRepeat = { value: 0.05 };
                shader.vertexShader = shader.vertexShader.replace('#include <common>', `#include <common>\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal;`);
                shader.vertexShader = shader.vertexShader.replace('#include <worldpos_vertex>', `#include <worldpos_vertex>\nvWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;\nvWorldNormal = normalize(mat3(modelMatrix) * normal);`);
                shader.fragmentShader = shader.fragmentShader.replace('#include <common>', `
                    #include <common>
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    uniform float uRepeat;
                    vec3 getTriplanarBlend(vec3 normal) {
                        vec3 blend = abs(normal); blend = pow(blend, vec3(4.0));
                        return blend / (blend.x + blend.y + blend.z);
                    }
                    vec4 triplanarTexture(sampler2D tex, vec3 worldPos, vec3 normal, float scale) {
                        // ç«–ç›´æ‹‰ä¸ï¼šYä½œä¸ºU
                        vec2 uvXY = vec2(worldPos.y, worldPos.x) * scale;
                        vec2 uvZY = vec2(worldPos.y, worldPos.z) * scale;
                        vec2 uvXZ = vec2(worldPos.z, worldPos.x) * scale;
                        vec4 colX = texture2D(tex, uvZY);
                        vec4 colY = texture2D(tex, uvXZ);
                        vec4 colZ = texture2D(tex, uvXY);
                        vec3 blend = getTriplanarBlend(normal);
                        return colX * blend.x + colY * blend.y + colZ * blend.z;
                    }
                `);
                shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `
                    #ifdef USE_MAP
                        vec4 sampledColor = triplanarTexture(map, vWorldPosition, vWorldNormal, uRepeat);
                        diffuseColor.rgb *= (sampledColor.rgb ); 
                    #endif
                `);
                shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', `
                    float roughnessFactor = roughness;
                    #ifdef USE_ROUGHNESSMAP
                        roughnessFactor *= triplanarTexture(roughnessMap, vWorldPosition, vWorldNormal, uRepeat).r;
                    #endif
                `);
            };
        }
        return mat;
    }

    // ==========================================
    // å­—ä½“åŠ è½½ä¸æ–‡æœ¬ç”Ÿæˆ
    // ==========================================
    const loadingEl = document.getElementById('loading');

    function getFontUrlByType(type) {
        switch(type) {
            case 'helvetiker': return 'https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json';
            case 'Forte': return 'fonts/Forte_Regular.json'; 
            case 'STXingkai_Regular': return 'fonts/STXingkai_Regular.json';
            default: return 'https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json';
        }
    }

    function loadFontAndGenerate(fontType, text, adjustCamera = true) {
        const url = getFontUrlByType(fontType);
        loadingEl.style.display = 'flex';
        
        fontLoader.load(url, function(font) {
            currentFont = font;
            loadingEl.style.display = 'none';
            generate3DText(text || document.getElementById('textInput').value, adjustCamera);
        }, undefined, function(err) {
            console.warn('å­—ä½“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è‹±æ–‡å­—ä½“', err);
            fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function(fallbackFont) {
                currentFont = fallbackFont;
                loadingEl.style.display = 'none';
                generate3DText(text || document.getElementById('textInput').value, adjustCamera);
                document.getElementById('fontSelector').value = 'helvetiker';
            });
        });
    }

   // ç”Ÿæˆ3Dæ–‡å­—
   function generate3DText(textString, adjustCamera = true) {
        if (!currentFont) {
            loadFontAndGenerate('helvetiker', textString, adjustCamera);
            return;
        }

        while(textGroup.children.length > 0){ 
            const obj = textGroup.children[0];
            if(obj.geometry) obj.geometry.dispose();
            if(obj.material) {
                if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                else obj.material.dispose();
            }
            textGroup.remove(obj); 
        }
        
        frontMeshes = [];
        backMeshes = [];
        singleMesh = null;

        if (!textString.trim()) return;

        // ============================
        // æ¨¡å¼: æ–¹ä½“ç¯ç®± (Box Light)
        // ============================
      // ============================
        // æ¨¡å¼: æ–¹ä½“ç¯ç®± (Box Light)
        // ============================
        if (glowMode === 'boxLight') {
            const textThickness = 2; // å®šä¹‰æ–‡å­—åšåº¦
            
            // 1. ç”Ÿæˆå†…éƒ¨é‡‘å±å­— (å®å¿ƒ)
            const textOpts = {
                font: currentFont, 
                size: 26,
                height: textThickness, // ä½¿ç”¨å˜é‡
                curveSegments: 6,
                bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 3
            };
            const textGeo = new TextGeometry(textString, textOpts);
            
            // å±…ä¸­æ–‡å­— (æ³¨æ„ï¼šZè½´ä¸è¦åœ¨è¿™é‡Œåç§»ï¼Œæ”¹ä¸ºåé¢ç”¨ position æ§åˆ¶)
            textGeo.computeBoundingBox();
            const textWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
            const textHeight = textGeo.boundingBox.max.y - textGeo.boundingBox.min.y;
            const centerOffsetX = -0.5 * textWidth;
            const centerOffsetY = -0.5 * textHeight;
            
            // ã€ä¿®æ”¹ç‚¹1ã€‘è¿™é‡Œ Z è½´è®¾ä¸º 0ï¼Œä¸å†æ˜¯ -1
            textGeo.translate(centerOffsetX, centerOffsetY, 0); 

            // 2. å‡†å¤‡å°ºå¯¸æ•°æ®
            const boxW = textWidth + (frontThickness * 4); // å®½åº¦æ‰©å±• (Padding X)
            const boxH = textHeight + (backThickness * 4); // é«˜åº¦æ‰©å±• (Padding Y)
            const boxD = boxDepth; // æ·±åº¦ (Zè½´åšåº¦)

            // é‡‘å±æè´¨
            const metalMat = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
            const innerMesh = new THREE.Mesh(textGeo, metalMat);
            
            // ã€ä¿®æ”¹ç‚¹2ã€‘è®¡ç®—æ–‡å­—ä½ç½®
            // ç¯ç®±ä¸­å¿ƒåœ¨0ï¼Œå‰è¡¨é¢åœ¨ boxD / 2ã€‚
            // æˆ‘ä»¬è®©æ–‡å­—ç¨å¾®åµŒå…¥ä¸€ç‚¹ç‚¹ (-0.2)ï¼Œé˜²æ­¢æ‚¬ç©ºï¼Œå‰©ä¸‹çš„éƒ¨åˆ†å‡¸èµ·
            innerMesh.position.z = (boxD / 2) - 0.2; 
            
            textGroup.add(innerMesh);
            frontMeshes.push(innerMesh); 

            // 3. ç”Ÿæˆå¤–éƒ¨å‘å…‰æ–¹ä½“ (Box)
            const boxGeo = new THREE.BoxGeometry(boxW, boxH, boxD);
            
            // å‘å…‰åŠé€æ˜æè´¨
            const ledColor = new THREE.Color(document.getElementById('ledColorPicker').value);
            const boxMat = new THREE.MeshPhysicalMaterial({
                color: ledColor,
                emissive: ledColor,
                emissiveIntensity: 0, 
                transmission: 0.6,    
                opacity: 0.6,
                transparent: true,
                roughness: 0.2,
                metalness: 0.1,
                side: THREE.FrontSide
            });

            const boxMesh = new THREE.Mesh(boxGeo, boxMat);
            boxMesh.position.set(0, 0, 0); // ç›’å­ä¿æŒåœ¨ä¸­å¿ƒ
            
            // å¼€å¯è¾‰å…‰
            boxMesh.layers.enable(BLOOM_SCENE);
            textGroup.add(boxMesh);
            backMeshes.push(boxMesh); 

            // æ›´æ–°äº®åº¦
            updateBrightness(document.getElementById('brightnessSlider').value);
        }

        // ============================
        // æ¨¡å¼: å•ä½“ (äºšå…‹åŠ› / é‡‘å±å­—)
        // ============================
        else if (glowMode === 'acrylicCut' || glowMode === 'metalCut') {
            const totalThickness = frontThickness + backThickness;
            const opts = {
                font: currentFont, 
                size: 26,
                height: totalThickness,
                curveSegments: 6,
                bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 3
            };
            const geo = new TextGeometry(textString, opts);
            
            geo.computeBoundingBox();
            const centerOffset = -0.5 * (geo.boundingBox.max.x - geo.boundingBox.min.x);
            const centerY = -0.5 * (geo.boundingBox.max.y - geo.boundingBox.min.y);
            geo.translate(centerOffset, centerY, 0);

            const matType = glowMode;
            let mat;
            if (matType === 'acrylicCut') {
                const col = new THREE.Color(document.getElementById('ledColorPicker').value);
                mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.2, metalness: 0.0, side: THREE.DoubleSide });
            } else {
                mat = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
            }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.z = -backThickness;
            mesh.userData.baseZ = -backThickness;
            textGroup.add(mesh);
            singleMesh = mesh;
        } 
        
        // ============================
        // æ¨¡å¼: åŒå±‚ (é‡‘å±å‘å…‰å­—)
        // ============================
        else {
            const isBackGlow = (glowMode === 'backGlow');
            const frontOpts = { font: currentFont, size: 26, height: frontThickness, curveSegments: 6, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 3 };
            const backOpts = { font: currentFont, size: 26, height: backThickness, curveSegments: 6, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 3 };
            
            const frontGeo = new TextGeometry(textString, frontOpts);
            const backGeo = new TextGeometry(textString, backOpts);
            
            frontGeo.computeBoundingBox();
            const centerOffset = -0.5 * (frontGeo.boundingBox.max.x - frontGeo.boundingBox.min.x);
            const centerY = -0.5 * (frontGeo.boundingBox.max.y - frontGeo.boundingBox.min.y);
            frontGeo.translate(centerOffset, centerY, 0);
            backGeo.translate(centerOffset, centerY, 0);
            frontGeo.computeBoundingBox();
            backGeo.computeBoundingBox();

            const frontZ = -frontGeo.boundingBox.min.z; 
            const backZ = -backGeo.boundingBox.max.z;

            const ledColor = new THREE.Color(document.getElementById('ledColorPicker').value);
            const ledMat = new THREE.MeshStandardMaterial({ color: ledColor, emissive: ledColor, emissiveIntensity: 0, toneMapped: false });
            const capMat = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);

            const frontMesh = new THREE.Mesh(frontGeo, isBackGlow ? capMat : ledMat);
            frontMesh.position.z = frontZ;
            frontMesh.userData.baseZ = frontZ; 
            if (!isBackGlow) frontMesh.layers.enable(BLOOM_SCENE);
            textGroup.add(frontMesh);
            frontMeshes.push(frontMesh);

            const backMesh = new THREE.Mesh(backGeo, isBackGlow ? ledMat : capMat);
            backMesh.position.z = backZ;
            backMesh.userData.baseZ = backZ;
            if (isBackGlow) backMesh.layers.enable(BLOOM_SCENE);
            textGroup.add(backMesh);
            backMeshes.push(backMesh);
            
            updateBrightness(document.getElementById('brightnessSlider').value);
        }

        if (adjustCamera) {
            centerAndFitCamera();
        }

        // è§£ä½“æŒ‰é’®é€»è¾‘
        isDecomposed = false;
        const isSingle = (glowMode === 'acrylicCut' || glowMode === 'metalCut' || glowMode === 'boxLight');
        document.getElementById('decomposeBtn').disabled = isSingle;
        document.getElementById('decomposeBtn').innerText = isSingle ? 'ä¸å¯è§£ä½“ (Single Object)' : 'ä¸€é”®è§£ä½“ (Explode)';
    }

    function centerAndFitCamera() {
        if (textGroup.children.length === 0) return;
        const box = new THREE.Box3().setFromObject(textGroup);
        const center = box.getCenter(new THREE.Vector3());
        
        textGroup.position.x = -center.x;
        textGroup.position.y = -center.y;
        
        const newBox = new THREE.Box3().setFromObject(textGroup);
        const bottomY = newBox.min.y; 
        const floorHeight = bottomY - 0.5;
        gridHelper.position.y = floorHeight;
        xAxis.position.y = floorHeight;
        zAxis.position.y = floorHeight;

        const size = newBox.getSize(new THREE.Vector3());
        let cameraDist = Math.max(size.x, size.y, size.z) * 1.5;
        camera.position.set(0, 0, cameraDist);
        controls.target.set(0, 0, 0);
        controls.update();
        
        scene.fog.near = cameraDist * 0.5;
        scene.fog.far = cameraDist * 5.0;
    }

    // ==========================================
    // UI çŠ¶æ€æ§åˆ¶å‡½æ•°
    // ==========================================
    function updateUIState() {
        const matSection = document.getElementById('materialSection');
        const tintSection = document.getElementById('tintSection');
        const ledSection = document.getElementById('ledSection');
        const ledPicker = document.getElementById('ledColorPicker');
        const ledLabel = document.getElementById('ledColorLabel');
        const brightDiv = document.getElementById('brightnessControl');
        
        const frontLabel = document.getElementById('frontLabel');
        const backLabel = document.getElementById('backLabel');
        const frontDesc = document.getElementById('frontDesc');
        const backDesc = document.getElementById('backDesc');
        const depthControl = document.getElementById('depthControl');

        // é‡ç½®é€šç”¨çŠ¶æ€
        matSection.classList.remove('disabled-overlay');
        tintSection.classList.remove('disabled-overlay');
        ledPicker.classList.remove('disabled-picker');
        ledPicker.disabled = false;
        brightDiv.style.opacity = '1';
        document.getElementById('brightnessSlider').disabled = false;
        ledLabel.innerText = 'ğŸ’¡ ç¯å…‰é¢œè‰² (LED Color)';
        depthControl.classList.add('hidden'); // é»˜è®¤éšè—å®½åº¦æ§åˆ¶
        
        // æ¢å¤æ»‘å—é»˜è®¤æ ‡ç­¾
        frontLabel.innerHTML = 'ğŸ“ æ­£é¢åšåº¦ (<span id="frontThicknessValue">' + frontThickness.toFixed(1) + '</span>)';
        backLabel.innerHTML = 'ğŸ“ èƒŒé¢åšåº¦ (<span id="backThicknessValue">' + backThickness.toFixed(1) + '</span>)';
        frontDesc.innerText = 'å‘å‰å‡¸èµ·';
        backDesc.innerText = 'å‘åå‡¸èµ·';

        if (glowMode === 'acrylicCut') {
            matSection.classList.add('disabled-overlay');
            tintSection.classList.add('disabled-overlay');
            brightDiv.style.opacity = '0.3';
            document.getElementById('brightnessSlider').disabled = true;
            ledLabel.innerText = 'ğŸ¨ æœ¬ä½“é¢œè‰² (Body Color)';
        } 
        else if (glowMode === 'metalCut') {
            ledPicker.classList.add('disabled-picker');
            ledPicker.disabled = true;
            brightDiv.style.opacity = '0.3';
            document.getElementById('brightnessSlider').disabled = true;
            ledLabel.innerText = 'ğŸ’¡ ç¯å…‰ (ä¸å¯ç”¨)';
        }
        else if (glowMode === 'boxLight') {
            // æ–¹ä½“ç¯ç®±æ¨¡å¼
            // æè´¨/Tintæ§åˆ¶é‡‘å±å­— (å¯ç”¨)
            // LEDæ§åˆ¶ç¯ç®±é¢œè‰² (å¯ç”¨)
            
            // æ ‡ç­¾æ›´å
            frontLabel.innerHTML = 'ğŸ“ æ§åˆ¶ç¯ç®±é•¿ (<span id="frontThicknessValue">' + frontThickness.toFixed(1) + '</span>)';
            backLabel.innerHTML = 'ğŸ“ æ§åˆ¶ç¯ç®±é«˜ (<span id="backThicknessValue">' + backThickness.toFixed(1) + '</span>)';
            frontDesc.innerText = 'Xè½´æ–¹å‘æ‰©å±•';
            backDesc.innerText = 'Yè½´æ–¹å‘æ‰©å±•';
            
            // æ˜¾ç¤ºå®½åº¦æ§åˆ¶
            depthControl.classList.remove('hidden');
        }
    }

    // ==========================================
    // äº¤äº’é€»è¾‘
    // ==========================================
    function updateBrightness(percent) {
        if (glowMode === 'acrylicCut' || glowMode === 'metalCut') return;

        const ledIntensity = (percent / 100) * 3.0;   
        document.getElementById('brightnessValue').textContent = `${Math.round(percent)}%`;
        
        if (glowMode === 'boxLight') {
            // ç¯ç®±æ¨¡å¼ï¼šæ”¹å˜ backMeshes (å­˜å‚¨çš„æ˜¯box) çš„å‘å…‰
            backMeshes.forEach(obj => obj.material.emissiveIntensity = ledIntensity);
        } else if (glowMode === 'backGlow') {
            backMeshes.forEach(obj => obj.material.emissiveIntensity = ledIntensity);
        } else {
            frontMeshes.forEach(obj => obj.material.emissiveIntensity = ledIntensity);
        }
    }

    document.getElementById('brightnessSlider').addEventListener('input', (e) => updateBrightness(e.target.value));
    
    document.getElementById('ledColorPicker').addEventListener('input', (e) => {
        const col = new THREE.Color(e.target.value);
        
        if (glowMode === 'boxLight') {
            // ç¯ç®±ï¼šæ”¹å˜ Box é¢œè‰² (Box å­˜å‚¨åœ¨ backMeshes)
            backMeshes.forEach(obj => { 
                obj.material.color.copy(col); 
                obj.material.emissive.copy(col); 
            });
        } else if (glowMode === 'acrylicCut') {
            if (singleMesh) singleMesh.material.color.copy(col);
        } else if (glowMode === 'metalCut') {
            // Pass
        } else {
            if (glowMode === 'backGlow') {
                backMeshes.forEach(obj => { obj.material.color.copy(col); obj.material.emissive.copy(col); });
            } else {
                frontMeshes.forEach(obj => { obj.material.color.copy(col); obj.material.emissive.copy(col); });
            }
        }
    });

    document.getElementById('frontColorPicker').addEventListener('input', (e) => {
        currentTintColor = new THREE.Color(e.target.value);
        
        if (glowMode === 'acrylicCut') return;
        
        if (glowMode === 'boxLight') {
            // ç¯ç®±ï¼šæ”¹å˜å†…éƒ¨é‡‘å±å­— (å­˜å‚¨åœ¨ frontMeshes)
            frontMeshes.forEach(obj => {
                obj.material.dispose();
                obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
            });
        } else if (glowMode === 'metalCut') {
            if (singleMesh) {
                singleMesh.material.dispose();
                singleMesh.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
            }
        } else {
            if (glowMode === 'backGlow') {
                frontMeshes.forEach(obj => {
                    obj.material.dispose();
                    obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
                });
            } else {
                backMeshes.forEach(obj => {
                    obj.material.dispose();
                    obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
                });
            }
        }
    });

    document.querySelectorAll('#materialOptions .material-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            if (glowMode === 'acrylicCut') return; 

            document.querySelectorAll('.material-btn').forEach(b => b.classList.remove('active'));
            e.currentTarget.classList.add('active');
            
            const type = e.currentTarget.dataset.type;
            
            if (type === 'metal011') {
                currentTexName = 'Metal011'; currentIsBrushed = true; currentTintColor = 0xffffff;
            } else if (type === 'metal049a') {
                currentTexName = 'Metal049A'; currentIsBrushed = false; currentTintColor = 0xffffff;
            } else if (type === 'copper_brushed') {
                currentTexName = 'Metal011'; currentIsBrushed = true; currentTintColor = 0xc07c51;
            } else if (type === 'copper_mirror') {
                currentTexName = 'Metal049A'; currentIsBrushed = false; currentTintColor = 0xc07c51;
            }

            const hexColor = '#' + new THREE.Color(currentTintColor).getHexString();
            document.getElementById('frontColorPicker').value = hexColor;

            if (glowMode === 'boxLight') {
                // ç¯ç®±å†…éƒ¨é‡‘å±å­—
                frontMeshes.forEach(obj => {
                    obj.material.dispose();
                    obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
                });
            } else if (glowMode === 'metalCut') {
                if (singleMesh) {
                    singleMesh.material.dispose();
                    singleMesh.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor);
                }
            } else if (glowMode === 'backGlow') {
                frontMeshes.forEach(obj => { 
                    obj.material.dispose(); 
                    obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor); 
                });
            } else {
                backMeshes.forEach(obj => { 
                    obj.material.dispose(); 
                    obj.material = createBackMaterial(currentTexName, currentIsBrushed, currentTintColor); 
                });
            }
        });
    });

    document.getElementById('craftSelect').addEventListener('change', (e) => {
        glowMode = e.target.value;
        updateUIState(); 
        generate3DText(document.getElementById('textInput').value, true);
        
        // æ¢å¤äº®åº¦æ˜¾ç¤º
        if (glowMode !== 'acrylicCut' && glowMode !== 'metalCut') {
            updateBrightness(document.getElementById('brightnessSlider').value);
        }
    });

    const frontSlider = document.getElementById('frontThicknessSlider');
    const frontSpan = document.getElementById('frontThicknessValue');
    frontSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        frontSpan.textContent = val.toFixed(1);
        frontThickness = val;
        // å®æ—¶æ›´æ–° geometry éœ€è¦é‡æ–°ç”Ÿæˆï¼Œä¸ºäº†æ€§èƒ½å¦‚æœæ˜¯boxLightåªç¼©æ”¾Meshå¯èƒ½æ›´å¥½ï¼Œ
        // ä½†ä¸ºäº†ç®€å•ç»Ÿä¸€ï¼Œç›´æ¥è°ƒç”¨ generate3DText
        generate3DText(document.getElementById('textInput').value, false);
    });

    const backSlider = document.getElementById('backThicknessSlider');
    const backSpan = document.getElementById('backThicknessValue');
    backSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        backSpan.textContent = val.toFixed(1);
        backThickness = val;
        generate3DText(document.getElementById('textInput').value, false);
    });
    
    // æ–°å¢ï¼šç¯ç®±å®½åº¦æ»‘å—
    const depthSlider = document.getElementById('depthSlider');
    const depthSpan = document.getElementById('depthValue');
    depthSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        depthSpan.textContent = val.toFixed(1);
        boxDepth = val;
        if (glowMode === 'boxLight') {
            generate3DText(document.getElementById('textInput').value, false);
        }
    });

    document.getElementById('decomposeBtn').addEventListener('click', () => {
        if (glowMode === 'acrylicCut' || glowMode === 'metalCut' || glowMode === 'boxLight') return; 

        isDecomposed = !isDecomposed;
        const gap = 20; 

        if (frontMeshes.length > 0 && backMeshes.length > 0) {
            const fMesh = frontMeshes[0];
            const bMesh = backMeshes[0];

            if (isDecomposed) {
                gsap.to(fMesh.position, { z: fMesh.userData.baseZ + gap, duration: 1, ease: "power2.inOut" });
                gsap.to(bMesh.position, { z: bMesh.userData.baseZ - gap, duration: 1, ease: "power2.inOut" });
            } else {
                gsap.to(fMesh.position, { z: fMesh.userData.baseZ, duration: 1, ease: "power2.inOut" });
                gsap.to(bMesh.position, { z: bMesh.userData.baseZ, duration: 1, ease: "power2.inOut" });
            }
        }
        
        document.getElementById('decomposeBtn').innerText = isDecomposed ? 'ä¸€é”®åˆå¹¶' : 'ä¸€é”®è§£ä½“ (Explode)';
    });

    document.getElementById('textInput').addEventListener('input', (e) => {
        if (currentFont) generate3DText(e.target.value, true);
    });

    document.getElementById('fontSelector').addEventListener('change', (e) => {
        const selected = e.target.value;
        const currentText = document.getElementById('textInput').value;
        loadFontAndGenerate(selected, currentText, true);
    });

    // åˆå§‹åŒ–
    updateUIState();
    loadFontAndGenerate('helvetiker', document.getElementById('textInput').value, true);

    // ==========================================
    // æ¸²æŸ“å¾ªç¯
    // ==========================================
    function darkenNonBloomed(obj) {
        if (bloomLayer.test(obj.layers) === false) {
            if (obj.isMesh) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            } else if (obj.isLine || obj.isLineSegments) {
                materials[obj.uuid] = obj.material;
                obj.material = darkLineMaterial;
            }
        }
    }

    function restoreMaterial(obj) {
        if (materials[obj.uuid]) {
            obj.material = materials[obj.uuid];
            delete materials[obj.uuid];
        }
    }

    function animate() { 
        requestAnimationFrame(animate); 
        controls.update(); 

        const originalBg = scene.background;
        scene.background = new THREE.Color(0x000000);

        scene.traverse(darkenNonBloomed);
        bloomComposer.render();

        scene.traverse(restoreMaterial);
        scene.background = originalBg;

        finalComposer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        bloomComposer.setSize(container.clientWidth, container.clientHeight);
        finalComposer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
</script>
</body>
</html>